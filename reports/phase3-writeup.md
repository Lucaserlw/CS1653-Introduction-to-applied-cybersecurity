# CS 1653 Term Project Phase 3 Writeup

### Group Information

Name | Email | Github
---|---|---
Wuyue Liu | wul5@pitt.edu | Lucaserlw
Jakob Ross | jjr113@pitt.edu | jjr113
Sean Lord | sal244@pitt.edu | LordOfBeans

## Threats

### Threat 1 - Unauthorized Token Issuance

#### Description

For this threat model, there is an assumption that clients are untrusted, and these clients may try or request tokens from the group server. If an unauthorized client manages to acquire a token, it will compromise the server's security and render the use of tokens for accessing and modifying groups and files meaningless.

#### Chosen Mechanism

Because we assumed that every client might be not trustworthy, all clients need to pass the verification using password before they get their token. When the administrator first creates the user, the server will automatically generate a one-time string consisting of 8 randomized characters. This string is hashed and stored by a secure digital signature algorithm like RSA with SHA-256 and a randomized salt. Then the administrator sent this password to the new user for first-time login. Once the user first login to the system, he is required to renew his password, and this password will be sent to the server for future login, and it will be stored by the algorithm mentioned above and with the salt generated above. Finally, a user's account is locked after three unsuccessful login attempts. The account must now be unlocked by an administrator, and the password-creation process is redone.

Here are steps on how this mechanism would work with Alice and the Authentication server:
1. Administrator creates the new user, Alice, with a new one-time password and is stored in the server.
2. Administrator sent this password to Alice.
3. Sny attempts to request a token without resetting the password will be denied.
4. Alice provides the one-time password and reset the password.
5. After the password changes, Alice can login into the system normally.

#### Argument
The proposed mechanism offers a high level of security against unauthorized clients trying to get unauthorized access to the file system.The system will lock the profile being attempted to access if an adversary attempts to use an online dictionary attack against it after numerous unsuccessful guesses. The salted nature of the derived key also protects against a rainbow table attack, as the salt will force the hash dictionary to be recomputed for every password.

### Threat 2 - Token Modification/Forgery

#### Description

When a client manipulates their token to gain unauthorized access or increase their privileges within the system, this is known as token modification or forging. This has the potential to jeopardize the integrity of the messaging-sharing service in our application, resulting in security breaches and unauthorized message access. An illustration of this threat in action in our system would be when a user with restricted access tries to enter the "Admins" channel without authorization by modifying their token. The user then intercepts the token issued by the authentication server and changes its contents to grant the user elevated privileges.

#### Chosen Mechanism

To address this issue, we will expand the UserToken interface and include new cryptographic measures to guarantee the integrity and validity of tokens. We will first create the token structure with relevant data, like the user's identity, access privileges, and expiration date. The authentication server will then use a digital signature method to cryptographically sign this data. Second, each token that the authentication server issues will have a digital signature created. To ensure non-repudiation and tamper resistance, the signature will be generated using a secure digital signature algorithm, such as RSA with SHA-256. The token will be signed using the authentication server's private key and verified using its public key. Lastly, the public key of the authentication server is also accessible to host servers and other parties that require token verification. By confirming a token's digital signature, they can utilize this key to confirm its authenticity and integrity. If the signature is reliable, it verifies that the token was generated by the authentication server and was not altered.

Here are steps on how this mechanism would work with Alice and the Authentication server:
1. Alice initiates the authentication process by sending a request to the authentication server, indicating her intent to authenticate and obtain a token.
2. The authentication server receives Alice's request and verifies her identity.
3. Upon successful identity verification, the authentication server generates a token for Alice.
4. The authentication server signs the token using a digital signature algorithm, such as RSA with SHA-256.
5. The authentication server appends the digital signature to the token, creating a complete token with the user's information and the attached digital signature.
6. The signed token is then sent back to Alice, responding to her authentication request.
7. Alice receives the token from the authentication server.
8. Before using the token, Alice independently verifies its integrity and authenticity using the authentication server's public key.
9. Alice decrypts the digital signature using the authentication server's public key and compares it with the computed hash value.
10. If the decrypted value matches the computed hash value, the token is considered valid and verified.

#### Argument

The proposed mechanism uses strong cryptographic methods to protect against token tampering and forgery. One way this approach sufficiently addresses this threat is by having the authentication server's private key necessary to generate a valid signature, thanks to the digital signature method employed in the token generation procedure. The tokens cannot be forged or altered discreetly as long as the private key is kept secure. RSA with SHA-256, the chosen digital signature technique, is also well-known and regarded as secure. It offers the required security assurances, such as non-repudiation, integrity, and tamper resistance, that we need to secure our messaging application.

### Threat 3 - Unauthorized Host Servers

#### Description

Whenever a user chooses to connect to a host server, it’s important that the user can verify that the server they connect to is the same server they wanted to connect to. Imagine a case where a user prompts connection to a host server and is maliciously connected to a different server. While the user is convinced they are connected to the correct server, they could be prompted with misinformation or accidentally send confidential messages to our adversary. In our current insecure implementation, a user is given no indication that they are connected to the wrong host server. Assuming an adversary knows enough about how a group operates in the host server they’re attempting to mimic, they could create a convincing clone to attempt to get information from the user.

#### Chosen Mechanism

Given that any user can create a host server, we cannot rely on the authentication server to act as a certificate authority. Instead, we use a protocol to verify the public key of the host server we’re connected to and then we rely on the user to verify the correctness of the public key, or at least an abstraction of it.

Here are the steps required for Alice to authenticate a connection with a host server:
1. Alice generates a fresh random number and sends it to the host server.
3. The host server receives the random number $R$ and signs it with its private key.
3. The host server sends Alice its public key and its signature for $R$. In other words, it sends $(K_S, [R]K_S^{-1})$ to Alice.
4. Alice verifies the signature using R and the provided public key $K_S$. At this point, Alice knows that the server she’s communicating with is using a valid key pair and its public key is $K_S$.
5. Alice creates a SHA-256 hash of the public key $K_S$, representing the key fingerprint as used in SSH.
6. If Alice recognizes the key fingerprint as the correct fingerprint for the host server she wants to connect to, she saves the (server, fingerprint) pair locally.
7. Alice proceeds to a symmetric key exchange using the server’s public key $K_S$.

Here is a diagram summarizing the protocol outlined above:
![A diagram shows how Alice authenticates the server.](https://github.com/cs1653-2237/cs1653-term-project-cs1653-2237-jjr113-sal244-wul5/blob/main/reports/images/AuthenticationProtocol.png)

#### Argument

To illustrate what makes this protocol secure, it’s best to establish what assertions we can make at the end of each step. We will be going off of Alice’s steps in the diagram, not the ones written above.
1. In step one, Alice generates and sends a fresh random number. At this stage, it’s incredibly unlikely that the server has signed that particular random number before.
2. In step two, the server sends Alice its public key and its signature of the random number with its public key. After Alice uses the public key to verify that the server signed the random number, Alice can assert that the server she’s communicating with has a valid key pair and has the provided public key.
3. In step three, Alice performs a SHA-256 hash on the server’s public key to create a key fingerprint. This step does not allow us to make any new assertions, but it does prepare us for the next step.
4. In step four, Alice checks if she associates that fingerprint with the server she’s trying to connect to. While I’ve decided to use Alice here as an abstraction, this could really be either the client program storing and recognizing the fingerprint and server pair or it could be the user recognizing the fingerprint after having acquired it from another source. Either way, we can assert that the user has at one point recognized that this is the correct fingerprint for the server we’re trying to connect to.
5. In step five, Alice proceeds to a symmetric key exchange with the host server using the provided public key. Alice can now assert that any future communication through this connection using the shared secret can only be read by the correct host server.

### Threat 4 - Information Leakage via Passive Monitoring

#### Description

In this threat model, it is presumed that passive attackers such as nosy administrators are present. Consequently, any external observer can see all the communications exchanged between client and server applications. Therefore, it becomes crucial to secure the contents of all traffic in order to safeguard confidentiality. Confidentiality ensures the privacy of file contents and prevents the interception of tokens.

#### Chosen Mechanism

To counteract this threat model, we will employ a signed Diffie Hellman key exchange protocol for all communication. Prior to any interaction between a client and server, a signed Diffie Hellman key exchange will be performed. This process enables both the client and server to establish a fresh shared secret key before each interaction, ensuring perfect forward secrecy. Additionally, this method allows verification of the identities of both the user and the server by validating the signatures. Subsequently, all messages exchanged will be encrypted using the AES algorithm with the symmetric shared key.

#### Argument

The proposed protocol outlines the utilization of the Diffie-Hellman key exchange procedure. Diffie-Hellman is a widely recognized approach for establishing a secure cryptographic key over a public channel. The security of Diffie-Hellman is based on the complexity of solving the discrete logarithm problem, which does not have an efficient general solution known. Once a shared key is established, the communications will be safeguarded by encrypting the contents of the messages using the AES algorithm and the agreed-upon shared key.


